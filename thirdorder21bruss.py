#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt

###############################################################################
# 1) The Brusselator ODE
###############################################################################
def brusselator(t, Y, A=1.0, B=3.0):
    """
    ODE version of the Brusselator.
    Y = [u, v]
    Returns [du/dt, dv/dt].
    """
    u, v = Y
    du = A - (B + 1) * u + u**2 * v
    dv = B * u - u**2 * v
    return np.array([du, dv])


###############################################################################
# 2) 21-Stage ESRK Coefficients (3rd Order)
###############################################################################
a = np.array([
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0477859117523170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, -0.000342225369733892, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, -0.0379306642681654, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0713548421395141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259359352931570, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, -0.00953495091906422, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0904519523018936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, -0.000396135089732896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, -0.153935717033075, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, 0.000795951292330683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, -0.119588952205909, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.164687679052309, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, -0.151151371693320, 0, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, -0.185777493787929, 0, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, 0.181570806943121, 0, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, -0.157721301562393, 9.54651547687642e-5, 0, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, -0.157721301562393, 0.171838581104214, 0.188961619753159, 0, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, -0.157721301562393, 0.171838581104214, -0.159282253882384, 0.163589906237245, 0, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, -0.157721301562393, 0.171838581104214, -0.159282253882384, 0.153692305711512, -0.000244631681385317, 0, 0],
    [0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0259186933858971, 0.0106794630936747, -0.115335444191199, 0.157354569317741, 0.0996953916040489, 0.124626570680465, 0.0999254297810373, -0.157721301562393, 0.171838581104214, -0.159282253882384, 0.153692305711512, 0.135802482016176, -0.146394354124576, 0]
], dtype=float)

b = np.array([
    0.025918693385897126,  0.025918693385897126,  0.025918693385897126,
    0.025918693385897126,  0.025918693385897126,  0.025918693385897126,
    0.025918693385897126,  0.025918693385897126,  0.010679463093674657,
   -0.11533544419119937,   0.15735456931774092,   0.09969539160404886,
    0.12462657068046491,   0.09992542978103731,  -0.1577213015623934,
    0.17183858110421352,  -0.1592822538823839,    0.15369230571151177,
    0.13580248201617606,   0.12674481627127573,   0.14462984296865586
], dtype=float)


###############################################################################
# 3) Single Step of the ESRK-21 Method
###############################################################################
def esrk21_step(f, t, y, h, a, b):
    """
    Performs a single step of the 21-stage ESRK method:
       y_{n+1} = y_n + h * sum_j( b_j * k_j ).
    """
    s = len(b)  # should be 21
    k = [None]*s
    
    for i in range(s):
        # c_i = sum of a[i][:i]
        c_i = np.sum(a[i, :i])
        
        # Build the stage value:
        y_stage = y.copy()
        for j in range(i):
            y_stage += h * a[i,j] * k[j]
        
        # Evaluate slope:
        k[i] = f(t + c_i*h, y_stage)
    
    # Final combination:
    y_next = y.copy()
    for i in range(s):
        y_next += h * b[i] * k[i]
    
    return y_next


###############################################################################
# 4) Integrator Loop (Fixed Steps)
###############################################################################
def esrk21_solve(f, t0, y0, tmax, h, a, b):
    """
    Solve y' = f(t,y) from t = t0 up to t = tmax using 21-stage ESRK 
    with fixed stepsize h. Returns arrays (ts, ys).
    """
    n_steps = int(np.ceil((tmax - t0) / h))
    # Adjust to ensure the final step ends exactly at tmax
    h_final = (tmax - t0) / n_steps
    
    ts = np.zeros(n_steps + 1)
    ys = np.zeros((n_steps + 1, len(y0)))
    
    ts[0] = t0
    ys[0] = y0
    t_current = t0
    y_current = y0.copy()
    
    for n in range(n_steps):
        y_next = esrk21_step(f, t_current, y_current, h_final, a, b)
        t_current += h_final
        y_current = y_next
        
        ts[n+1] = t_current
        ys[n+1] = y_current
    
    return ts, ys


###############################################################################
# 5) Convergence Study
###############################################################################
def convergence_study():
    """
    We compare solutions at t = 1.0 for different step sizes h, 
    against a 'reference solution' obtained with a very fine step.
    We then plot error vs. h on a log–log scale, expecting slope ~ 3.
    """
    # We'll integrate from t=0 to t=1
    t0, tmax = 0.0, 1.0
    y0 = np.array([1.0, 1.0])  # initial condition

    # 5a) Reference solution with a very small h (e.g. 2^(-12)=1/4096)
    h_ref = 1.0 / 4096.0
    _, y_ref_arr = esrk21_solve(brusselator, t0, y0, tmax, h_ref, a, b)
    y_ref = y_ref_arr[-1]  # final solution at t=1 (very fine step)

    # 5b) Range of step sizes for the convergence test
    #     e.g. h = 1/16, 1/32, 1/64, 1/128, 1/256 ...
    #     (Adjust as needed.)
    #h_values = [1/16, 1/32, 1/64, 1/128, 1/256, 1/512]
    h_values = np.linspace(0.01, 0.001, 120)

    errors = []
    for h in h_values:
        _, y_sol = esrk21_solve(brusselator, t0, y0, tmax, h, a, b)
        y_end = y_sol[-1]
        # Compare to reference
        err = np.linalg.norm(y_end - y_ref, ord=np.inf)  # or 2-norm
        errors.append(err)

    # 5c) Plot error vs. step size in log–log scale
    plt.figure()
    plt.loglog(h_values, errors, 'o-', label="ESRK-21 errors")
    
    # Plot a reference line with slope = 3
    # We'll anchor the line around the first data point
    # slope=3 => error ~ C * h^3.  Let's pick C so that it passes 
    # through the first data point:
    C = errors[0] / (h_values[0]**3)
    # Build a line across the same h-range
    h_lin = np.array(h_values)
    err_line = C*(h_lin**3)
    plt.loglog(h_lin, err_line, '--', label="Slope 3 reference")
    
    plt.xlabel("Step size h")
    plt.ylabel("Error at t=1 (∞-norm)")
    plt.title("Convergence of ESRK-21 on  1D Brusselator")
    plt.legend()
    plt.grid(True)
    plt.show()


###############################################################################
# 6) Main Demo
###############################################################################
def main():
    # Part A: Simple example with step size h=0.01 up to t=10
    #         so we can see the time evolution.
    t0, tmax = 0.0, 10.0
    y0 = np.array([1.0, 1.0])
    h_demo = 0.01
    ts, ys = esrk21_solve(brusselator, t0, y0, tmax, h_demo, a, b)
    
    # Plot the solution
    plt.figure()
    plt.plot(ts, ys[:,0], label='u(t)')
    plt.plot(ts, ys[:,1], label='v(t)')
    plt.title("Brusselator ODE solved by 21-stage ESRK (3rd order), h=0.01")
    plt.xlabel("Time")
    plt.ylabel("u(t), v(t)")
    plt.legend(loc="best")
    plt.grid(True)
    plt.show()
    
    # Part B: Convergence study on [0,1] to check order ~ 3
    convergence_study()


if __name__ == "__main__":
    main()
